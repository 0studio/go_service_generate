package main

import (
	"fmt"
	"github.com/0studio/go_service_generate/generator"
	"os"
	"path/filepath"
	"strings"
)

// give abc.txt return abc
// give a/b/abc.txt return abc
func getFileName(fileName string) string {
	fileName = filepath.Base(fileName)
	idx := strings.Index(fileName, ".")
	if idx != -1 {
		return fileName[:idx]
	}
	return fileName
}
func makeString(s string, n int) (r string) {
	for i := 0; i < n; i++ {
		r += s
	}
	return

}
func Camelize(s string) (ret string) {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[0:1]) + s[1:]
}
func generateEntity(structDescriptionList []generator.StructDescription, property generator.Property, srcDir string) {
	outputF, err := os.OpenFile(filepath.Join(srcDir, fmt.Sprintf("entity_stub.go")), os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer outputF.Close()
	outputF.WriteString("package ")
	outputF.WriteString(property.PackageName)

	outputF.WriteString(" // do not edit this file ,this is generated by tools(https://github.com/0studio/go_service_generate)\n\n")
	outputF.WriteString("import (\n")
	outputF.WriteString("    \"fmt\"\n")
	outputF.WriteString("    \"time\"\n")
	outputF.WriteString("    \"github.com/0studio/bit\"\n")

	outputF.WriteString(")\n\n")
	outputF.WriteString("var ___importTime time.Time\n\n")
	outputF.WriteString("var ___importBit bit.BitInt32\n\n")
	outputF.WriteString("func bool2int(b bool) int {\n")
	outputF.WriteString("    if b {\n")
	outputF.WriteString("        return 1\n")
	outputF.WriteString("    } else {\n")
	outputF.WriteString("        return 0\n")
	outputF.WriteString("    }\n")
	outputF.WriteString("}\n")

	outputF.WriteString("func formatTime(t time.Time)string {\n")
	outputF.WriteString("    if t.IsZero() {\n")
	outputF.WriteString("        return `0`\n")
	outputF.WriteString("    } else {\n")
	outputF.WriteString("        return t.Format(`20060102150405`)\n")
	outputF.WriteString("    }\n")
	outputF.WriteString("}\n")

	for _, sd := range structDescriptionList {
		// 生成结构体
		outputF.WriteString(fmt.Sprintf("type %s struct{\n", sd.StructName))
		if len(sd.Fields) < 8 {
			outputF.WriteString("    Flag            bit.BitInt8\n")
		} else if len(sd.Fields) < 16 {
			outputF.WriteString("    Flag            bit.BitInt16\n")
		} else if len(sd.Fields) < 32 {
			outputF.WriteString("    Flag            bit.BitInt32\n")
		} else {
			outputF.WriteString("    Flag            bit.BitInt64\n")
		}

		for _, field := range sd.Fields {
			outputF.WriteString(fmt.Sprintf("    %s%s%s", field.FieldName, makeString(" ", 16-len(field.FieldName)), field.FieldGoType))
			if field.TagString != "" {
				outputF.WriteString(fmt.Sprintf(" `%s`", field.TagString))
			}
			if field.Comments != "" {
				outputF.WriteString(fmt.Sprintf(" // %s", field.Comments))
			}

			outputF.WriteString("\n")
		}
		outputF.WriteString("}\n")

		// 生成setter getter
		for idx, field := range sd.Fields {
			outputF.WriteString(fmt.Sprintf("func(this *%s) Set%s(value %s) {\n", sd.StructName, Camelize(field.FieldName), field.FieldGoType))
			outputF.WriteString(fmt.Sprintf("    this.%s = value\n", field.FieldName))
			outputF.WriteString(fmt.Sprintf("    this.Flag.SetFlag(%d)\n", idx))

			outputF.WriteString("}\n")
			outputF.WriteString(fmt.Sprintf("func(this %s) Get%s()(value %s) {\n", sd.StructName, Camelize(field.FieldName), field.FieldGoType))
			outputF.WriteString(fmt.Sprintf("    return this.%s\n", field.FieldName))
			outputF.WriteString("}\n")
			outputF.WriteString(fmt.Sprintf("func(this %s) Is%sModified()bool {\n", sd.StructName, Camelize(field.FieldName)))
			outputF.WriteString(fmt.Sprintf("    return this.Flag.IsPosTrue(%d)\n", idx))
			outputF.WriteString("}\n")
		}
		outputF.WriteString(fmt.Sprintf("func(this %s) IsDirty()bool {\n", sd.StructName))
		outputF.WriteString(fmt.Sprintf("    return this.Flag!=0\n"))
		outputF.WriteString("}\n")
		outputF.WriteString(fmt.Sprintf("func(this %s) ClearFlag() {\n", sd.StructName))
		outputF.WriteString(fmt.Sprintf("    this.Flag=0\n"))
		outputF.WriteString("}\n")

		outputF.WriteString(fmt.Sprintf("func(this %s) IsNew()bool {\n", sd.StructName))
		outputF.WriteString(fmt.Sprintf("    return this.Flag.IsPosTrue(%d)\n", len(sd.Fields)))
		outputF.WriteString("}\n")

		outputF.WriteString(sd.GenerateInsert())
		outputF.WriteString("\n")
		outputF.WriteString(sd.GenerateCreateTableFunc())
		outputF.WriteString("\n")
	}

}

// go run /main.go example/example_1.go
func main() {
	if len(os.Args) < 2 {
		fmt.Printf("please give a go struct defintion file as params like this : %s\n go_struct.go", os.Args[0])
		return
	}
	goStructFile := os.Args[1]
	srcDir := filepath.Dir(goStructFile)
	// if !strings.HasSuffix(goStructFile, ".go") {
	// 	fmt.Printf("the first param must be a go source file ,and some struct are defined there\n")
	// 	return
	// }
	structDescriptionList, property := generator.ParseStructFile(goStructFile)
	if len(structDescriptionList) == 0 {
		fmt.Println("no struct found in ", goStructFile)
		return
	}
	generateEntity(structDescriptionList, property, srcDir)

	sqlF, err := os.OpenFile(filepath.Join(srcDir, fmt.Sprintf("%s_create_table.sql", getFileName(goStructFile))), os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer sqlF.Close()
	for _, sd := range structDescriptionList {
		sql, err := sd.GenerateCreateTableSql()
		if err != nil {
			fmt.Println(err)
			continue
		}

		sqlF.WriteString(sql)
		sqlF.WriteString("\n")
	}
}
