package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func (sd StructDescription) generateMCPK1(pkField FieldDescriptoin, property Property, srcDir string) bool {
	outputF, err := os.OpenFile(filepath.Join(srcDir, fmt.Sprintf("storage_mc_stub.go")), os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
	if err != nil {
		fmt.Println(err)
		return false
	}

	defer outputF.Close()

	s := strings.Replace(MCTemplatePK1, "__package__", property.PackageName, -1)
	s = strings.Replace(s, "__Entity__", sd.StructName, -1)
	s = strings.Replace(s, "__PKType__", pkField.FieldGoType, -1)
	s = strings.Replace(s, "__PKFieldName__", pkField.FieldName, -1)

	var pkToString string
	if pkField.FieldGoType == "string" {
		pkToString = "k"
	} else if pkField.FieldGoType == "int" {
		pkToString = "str2int(k)"
	} else if pkField.FieldGoType == "int8" {
		pkToString = "str2int8(k)"
	} else if pkField.FieldGoType == "int16" {
		pkToString = "str2int16(k)"
	} else if pkField.FieldGoType == "int32" {
		pkToString = "str2int32(k)"
	} else if pkField.FieldGoType == "int64" {
		pkToString = "str2int64(k)"
	} else if pkField.FieldGoType == "uint8" {
		pkToString = "str2uint8(k)"
	} else if pkField.FieldGoType == "uint16" {
		pkToString = "str2uint16(k)"
	} else if pkField.FieldGoType == "uint32" {
		pkToString = "str2uint32(k)"
	} else if pkField.FieldGoType == "uint64" {
		pkToString = "str2uint64(k)"
	} else {
		pkToString = "k.String()"
	}
	s = strings.Replace(s, "__PK2String__", pkToString, -1)

	var pkFromString string
	if pkField.FieldGoType == "string" {
		pkFromString = "k=token"
	} else {
		pkFromString = "k.FromString(token)"
	}
	s = strings.Replace(s, "__PKFromString__", pkFromString, -1)

	var pkTypeList string
	if isTypeKeySum(pkField.FieldGoType) {
		pkTypeList = fmt.Sprintf("%sList", pkField.FieldGoType)
	} else {
		pkTypeList = fmt.Sprintf("[]%s", pkField.FieldGoType)
	}

	s = strings.Replace(s, "__PKTypeList__", pkTypeList, -1)
	outputF.WriteString(s)
	return true
}

const (
	MCTemplatePK1 = `// do not edit this file ,this is generated by tools(https://github.com/0studio/go_service_generator)
package __package__

import (
	key "github.com/0studio/storage_key"
	"github.com/dropbox/godropbox/memcache"
	"strings"
	"time"
)
var __importKeyMC key.KeyUint64

type MC__Entity__Storage struct {
	expireSeconds uint32
	prefix        string
	client        memcache.Client
}

func NewMC__Entity__Storage(client memcache.Client, expireSeconds uint32, prefix string) MC__Entity__Storage {
	return MC__Entity__Storage{expireSeconds: expireSeconds, prefix: prefix, client: client}
}

func (m MC__Entity__Storage) getMCKey(k __PKType__) string {
	return strings.Join([]string{m.prefix, __PK2String__}, "_")
}

func (m MC__Entity__Storage) getRawKey(PrefixKey string) (k __PKType__) {
	keys := strings.Split(PrefixKey, "_")
	token := keys[len(keys)-1]
	__PKFromString__
	// k.FromString(token)
	return
}

func (m MC__Entity__Storage) Get(k __PKType__, now time.Time) (e __Entity__, ok bool) {
	item := m.client.Get(m.getMCKey(k))
	if item.Error() != nil || item.Status() != memcache.StatusNoError {
		return
	}
	byteData := item.Value()
	if byteData == nil {
		return
	}

	e.UnSerial(byteData)
	if k != e.__PKFieldName__ {
		ok = false
		return
	}

	ok = true
	return
}

func (m MC__Entity__Storage) Add(e *__Entity__, now time.Time) (ok bool) {
	return m.Set(e, now)
}

func (m MC__Entity__Storage) Set(e *__Entity__, now time.Time) (ok bool) {
	item := memcache.Item{Key: m.getMCKey(e.__PKFieldName__), Value: e.Serial(), Expiration: m.expireSeconds}
	response := m.client.Set(&item)
	return response.Error() == nil

}

func (m MC__Entity__Storage) MultiGet(keys __PKTypeList__, now time.Time) (eMap __Entity__Map, ok bool) {
	prefixKeys := make([]string, len(keys))
	for idx, Key := range keys {
		prefixKeys[idx] = m.getMCKey(__PKType__(Key))
	}
	itemMap := m.client.GetMulti(prefixKeys)

	eMap = make(__Entity__Map)
	var e __Entity__
	for k, item := range itemMap {
		if len(item.Value()) == 0 {
			continue
		}
		if e.UnSerial(item.Value()) {
			eMap[m.getRawKey(k)] = e
		}
	}
	ok = true
	return
}
func (m MC__Entity__Storage) MultiUpdate(eMap __Entity__Map, now time.Time) (ok bool) {
	items := make([]memcache.Item, 0, len(eMap))
	itemsPtrList := make([]*memcache.Item, 0, len(eMap))
	var idx int = 0
	for k, e := range eMap {
		items = append(items, memcache.Item{Key: m.getMCKey(k), Value: e.Serial(), Expiration: m.expireSeconds})
		itemsPtrList = append(itemsPtrList, &(items[idx]))
		idx++
	}
	responses := m.client.SetMulti(itemsPtrList)
	for _, response := range responses {
		if response.Error() != nil {
			return false
		}
	}
	return true
}
func (m MC__Entity__Storage) Delete(k __PKType__) (ok bool) {
	response := m.client.Delete(m.getMCKey(k))
	return response.Error() == nil || response.Status() == memcache.StatusKeyNotFound
}
func (m MC__Entity__Storage) MultiDelete(keys __PKTypeList__) (ok bool) {
	prefixKeys := make([]string, len(keys), len(keys))
	for idx, k := range keys {
		prefixKeys[idx] = m.getMCKey(k)
	}
	responses := m.client.DeleteMulti(prefixKeys)
	for _, response := range responses {
		if response.Error() != nil && response.Status() != memcache.StatusKeyNotFound {
			return false
		}
	}
	return true
}
`
)
