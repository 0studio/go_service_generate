package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

func GenerateUtils(property Property, srcDir string) {
	outputF, err := os.OpenFile(filepath.Join(srcDir, fmt.Sprintf("utils_stub.go")), os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer outputF.Close()
	outputF.WriteString(
		fmt.Sprintf(
			`// do not edit this file ,this is generated by tools(https://github.com/0studio/go_service_generator)
package %s

import (
    "time"
	"strconv"
	"strings"
	key "github.com/0studio/storage_key"
)


func bool2int(b bool) int {
    if b {
        return 1
    } else {
        return 0
    }
}
func int2bool(i int)bool {
    if i == 0 {
        return false
    } else {
        return true
    }
}
func formatTime(t time.Time)string {
    if t.IsZero() {
        return "0"
    } else {
        return t.Format("20060102150405")
    }
}
func formatTimeUnix(t time.Time)int64 {
    if t.IsZero() {
        return 0
    } else {
        return t.Unix()
    }
}
func newTime(unix int64) (t time.Time){
    if unix==0 {
        return
    } else {
        return time.Unix(unix,0)
    }
}

func uint64ListJoin(intLi []uint64, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatUint(v, 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}

func int64ListJoin(intLi []int64, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatInt(v, 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}
func uint32ListJoin(intLi []uint32, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatUint(uint64(v), 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}
func int32ListJoin(intLi []int32, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatInt(int64(v), 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}

func intListJoin(intLi []int, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.Itoa(v)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}

func uint16ListJoin(intLi []uint16, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatUint(uint64(v), 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}
func int16ListJoin(intLi []int16, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatInt(int64(v), 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}

func uint8ListJoin(intLi []uint8, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatUint(uint64(v), 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}
func int8ListJoin(intLi []int8, separator string) string {
	strLi := make([]string, len(intLi))
	for index, v := range intLi {
		strValue := strconv.FormatInt(int64(v), 10)
		strLi[index] = strValue
	}
	return strings.Join(strLi, separator)
}
func str2uint64List(str string, separator string) (uintList []uint64) {
	strList := strings.Split(str, separator)
	uintList = make([]uint64, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseUint(token, 10, 0)
		uintList[i] = v
	}
	return
}
func str2uint32List(str string, separator string) (uintList []uint32) {
	strList := strings.Split(str, separator)
	uintList = make([]uint32, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseUint(token, 10, 0)
		uintList[i] = uint32(v)
	}
	return
}
func str2uint16List(str string, separator string) (uintList []uint16) {
	strList := strings.Split(str, separator)
	uintList = make([]uint16, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseUint(token, 10, 0)
		uintList[i] = uint16(v)
	}
	return
}
func str2uint8List(str string, separator string) (uintList []uint8) {
	strList := strings.Split(str, separator)
	uintList = make([]uint8, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseUint(token, 10, 0)
		uintList[i] = uint8(v)
	}
	return
}

func str2int64List(str string, separator string) (intList []int64) {
	strList := strings.Split(str, separator)
	intList = make([]int64, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseInt(token, 10, 0)
		intList[i] = v
	}
	return
}
func str2intList(str string, separator string) (intList []int) {
	strList := strings.Split(str, separator)
	intList = make([]int, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseInt(token, 10, 0)
		intList[i] = int(v)
	}
	return
}
func str2int32List(str string, separator string) (intList []int32) {
	strList := strings.Split(str, separator)
	intList = make([]int32, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseInt(token, 10, 0)
		intList[i] = int32(v)
	}
	return
}
func str2int16List(str string, separator string) (intList []int16) {
	strList := strings.Split(str, separator)
	intList = make([]int16, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseInt(token, 10, 0)
		intList[i] = int16(v)
	}
	return
}
func str2int8List(str string, separator string) (intList []int8) {
	strList := strings.Split(str, separator)
	intList = make([]int8, len(strList))
	for i, token := range strList {
		v, _ := strconv.ParseInt(token, 10, 0)
		intList[i] = int8(v)
	}
	return
}
func sround(s, c string) string {
	return c + s + c
}
func sroundJoin(sList []string, c, sep string) string {
	for i, s := range sList {
		sList[i] = sround(s, c)
	}
	return strings.Join(sList, sep)
}
func sroundJoin2(sList []key.String, c, sep string) string {
    var sList2 []string=make([]string,len(sList))
	for i, s := range sList {
		sList2[i] = sround(string(s), c)
	}
	return strings.Join(sList2, sep)
}
func sroundJoin3(sList []key.KeyString, c, sep string) string {
    var sList2 []string=make([]string,len(sList))
	for i, s := range sList {
		sList2[i] = sround(string(s), c)
	}
	return strings.Join(sList2, sep)
}



func join(list []string, sep string) string {
	return strings.Join(list,sep)
}

`, property.PackageName))

}
